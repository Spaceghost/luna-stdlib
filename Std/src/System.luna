import Std.Base

class PipeRequest:
    Inherit
    UseHandle: handle :: FileHandle
    CreatePipe
    NoStream

class BufferMode:
    NoBuffering
    LineBuffering
    BlockBuffering: size :: Maybe Int


native class FileHandle:
    def setBuffering bm: primHSetBuffering self bm
    def isOpen: primHIsOpen self
    def isClosed: primHIsClosed self
    def close: primHClose self
    def flush: primHFlush self
    def getContents: primHGetContents self
    def getLine: primHGetLine self
    def putText t: primHPutText self t
    def putLine t:
        primHPutText self (t + '\n')
        self.flush


class ProcessHandle:
    def waitForProcess: primWaitForProcess self

class ProcessResults:
    stdin  :: Maybe FileHandle
    stdout :: Maybe FileHandle
    stderr :: Maybe FileHandle
    handle :: ProcessHandle

    def waitForProcess: self.handle . waitForProcess

class ProcessDescription:
    command :: Text
    args    :: List Text
    stdin   :: Maybe PipeRequest
    stdout  :: Maybe PipeRequest
    stderr  :: Maybe PipeRequest

    def run: primRunProcess self

def withForkWait async body:
    mVar = newMVar
    def fork':
        res = async
        mVar.put res
    fork fork'
    body mVar.take

def readProcessWithExitCode path args input:
    cp = ProcessDescription path args (Just CreatePipe) (Just CreatePipe) (Just CreatePipe)
    pr = cp . run
    outh = pr . stdout . fromJust . getContents
    errh = pr . stderr . fromJust . getContents
    def action waitOut waitErr:
        unless (input . isEmpty) (pr . stdin . fromJust . putText input)
        pr . stdin . each .close
        o = waitOut
        e = waitErr
        (o, e)
    outErr = withForkWait (primEvaluate outh) (o: withForkWait (primEvaluate errh) (action o))
    ex = pr . waitForProcess
    (outErr . first, outErr . second, ex)


class Process:
    stdin :: Maybe FileHandle

    def runProcess path args input:
        inhpr = Just (self.stdin . maybe CreatePipe UseHandle)
        cp = ProcessDescription path args inhpr (Just CreatePipe) (Just CreatePipe)
        pr = cp . run
        unless (input . isEmpty) (pr . stdin . fromJust . putText input)
        pr . stdin . each .close
        pr . stdout . fromJust

    def streamProcess path args input:
        outh = self . runProcess path args input
        streamFrom outh.getLine

def runProcessFromStream path args inputStream input:
    cp = ProcessDescription path args (Just CreatePipe) (Just CreatePipe) (Just CreatePipe)
    pr = cp . run
    inh = pr . stdin . fromJust
    inh.setBuffering NoBuffering
    outh = pr . stdout . fromJust
    outh.setBuffering NoBuffering
    fork (inputStream . each inh.putLine)
    streamFrom outh.getLine

class ExitCode:
    ExitSuccess
    ExitFailure: errorCode :: Int

    def toInt: case self of
        ExitSuccess: 0
        ExitFailure e: e

    def exitSuccess: case self of
        ExitSuccess: True
        ExitFailure e: False

    def exitFailure: case self of
        ExitFailure e: True
        ExitSuccess: False

    def toText: case self of
        ExitSuccess: "ExitSuccess"
        ExitFailure e: "ExitFailure " + e.toText

    def shortRep: self . toText
