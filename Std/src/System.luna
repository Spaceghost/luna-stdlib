import Std.Base

class PipeRequest:
    Inherit
    UseHandle: handle :: FileHandle
    CreatePipe
    NoStream

class BufferMode:
    NoBuffering
    LineBuffering
    BlockBuffering: size :: Maybe Int


native class FileHandle:
    def setBuffering bm: primHSetBuffering self bm
    def isOpen: primHIsOpen self
    def isClosed: primHIsClosed self
    def close: primHClose self
    def flush: primHFlush self
    def getContents: primHGetContents self
    def getLine: primHGetLine self
    def putText t: primHPutText self t
    def putLine t:
        primHPutText self (t + '\n')
        self.flush


class ProcessHandle:
    def waitForProcess: primWaitForProcess self

class ProcessResults:
    stdin  :: Maybe FileHandle
    stdout :: Maybe FileHandle
    stderr :: Maybe FileHandle
    handle :: ProcessHandle

    def waitForProcess: self.handle . waitForProcess

class Process:
    command :: Text
    args    :: List Text
    stdin   :: PipeRequest
    stdout  :: PipeRequest
    stderr  :: PipeRequest
    input   :: Either Text (Stream Text)

    def setCommand command: case self of
        Process _ args stdin stdout stderr input: Process command args stdin stdout stderr input

    def setArgs args: case self of
        Process command _ stdin stdout stderr input: Process command args stdin stdout stderr input

    def setStdin stdin: case self of
        Process command args _ stdout stderr input: Process command args stdin stdout stderr input

    def setStdout stdout: case self of
        Process command args stdin _ stderr input: Process command args stdin stdout stderr input

    def setStderr stderr: case self of
        Process command args stdin stdout _ input: Process command args stdin stdout stderr input

    def setInput input: case self of
        Process command args stdin stdout stderr _: Process command args stdin stdout stderr (Left input)

    def setInputStream inputStream: case self of
        Process command args stdin stdout stderr _: Process command args stdin stdout stderr (Right inputStream)

    def run:
        pr = primRunProcess self
        def applyInput t:
            unless (t.isEmpty) (pr.stdin.fromJust.putText t)
            pr.stdin.each .close
            None
        def applyStream s: fork (s.each pr.stdin.fromJust.putLine)
        self.input.either applyInput applyStream
        pr.stdout.fromJust

    def runStream:
        streamFrom self.run.getLine

    def execute:
        def throwStreamError: errorStr "Cannot execute process when input is infinite stream"
        def executeProcess:
            pr = primRunProcess self
            outh = pr.stdout.fromJust.getContents
            errh = pr.stderr.fromJust.getContents
            def action waitOut waitErr:
                unless self.input.left.isEmpty (pr.stdin.fromJust.putText self.input.left)
                pr.stdin.each .close
                o = waitOut
                e = waitErr
                (o, e)
            outErr = withForkWait (primEvaluate outh) (o: withForkWait (primEvaluate errh) (action o))
            ex = pr.waitForProcess
            (outErr.first, outErr.second, ex)
        if self.input.isLeft then executeProcess else throwStreamError


def defaultProcess command args:
    Process command args CreatePipe CreatePipe CreatePipe (Left "")

def withForkWait async body:
    mVar = newMVar
    def fork':
        res = async
        mVar.put res
    fork fork'
    body mVar.take

class ExitCode:
    ExitSuccess
    ExitFailure: errorCode :: Int

    def toInt: case self of
        ExitSuccess: 0
        ExitFailure e: e

    def exitSuccess: case self of
        ExitSuccess: True
        ExitFailure e: False

    def exitFailure: case self of
        ExitFailure e: True
        ExitSuccess: False

    def toText: case self of
        ExitSuccess: "ExitSuccess"
        ExitFailure e: "ExitFailure " + e.toText

    def shortRep: self . toText
